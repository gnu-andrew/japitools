#!/usr/bin/perl -w
###############################################################################
# japicompat - Test Java APIs for binary backwards compatibility.
# Copyright (C) 2000-2002  Stuart Ballard <sballard@netreach.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################

# Old-ish list of changes... stopped updating this list a while back but don't
# want to lose the history...
# - 2002/09/09: Abort on mis-ordered japi files since the results would be
#   incorrect. Add "interfaces" back into the summary. Treat constructors as
#   not inherited.
# - 2002/08/01: Update to handle version 0.9 japi files. Add back the summary
#   of errors at the end (minus "nnn good" which can't be calculated).
# - 2002/07/31: Fixed a nasty hang-at-end-of-file bug and a bug that caused
#   japicompat to think packages were missing when they weren't.
# - 2002/07/30: Rewritten version works apparently correctly, for the first
#   time. Summary information printed per-package as well as globally.
# - 2002/07/08: Beginnings of major rewrite to process japis efficiently.
#   Instead of loading a whole japi into memory, process the files in parallel.
#   Defer dup-elimination to a second pass.
# - 2002/06/27: Support new file format produced by japize 0.8.1. Remove ".pl"
#   from the end of the filename. Automatically pipe through gzip if the
#   filename ends with .gz.
# - 2000/06/30: Detect old-style japis and give a useful error. Make this
#   program -w clean. A few performance enhancements. Count abstract methods
#   added to classes/interfaces if -s is off.
# - 2000/06/29: Changes to support slight changes to file format.
# - 2000/06/26: Added progress indicators. Turn them off with -q.
# - 2000/06/23: Made compiletime-constants actually be understood, rather than
#   just treated as part of the type. Added Meaningless, Arbitrary Percentage
#   scores.
# - 2000/06/18: Added support for SerialVersionUIDs, fixed a mis-counting bug
#   caused by the elimination of duplicate errors ("missing" errors were being
#   counted even if they were dups). Added getopt support.
# - 2000/06/16: Finished the dup-removal code (Kaffe now shows 140 errors
#   instead of 429).


## GLOBAL VARIABLES ##

# Some global variables used for displaying stuff.
$japiver = "0.9.5";
@static = ('instance', 'static');
@ofhs = ();

# Requirements
use IO::Handle;
use IO::File;
use IO::Pipe;
use Getopt::Std;

# Function prototypes
sub open_japi($);
sub read_japi_item($);
sub close_japi($);
sub output_error($$$$$$$;$);
sub compare_japis($$);
sub compare_japi_item($$$$);
sub merge_results();
sub print_summary();
sub sig2type($);


## MAIN LOOP ##

# Parse cmdline and give a usage message.
getopts("svqhtjo:", \%opts);
my $sun_only = 1 if $opts{"s"};
my $svuid_errors = 1 if $opts{"v"};
my $dot = $opts{"q"} ? "" : ".";
my $outprog = $opts{"h"} ? "japiohtml" : $opts{"j"} ? undef : "japiotext";
my ($origfile, $newfile) = @ARGV;
if (!defined $newfile) {
  print STDERR "Usage: japicompat [-svqhtj] [-o outfile] <original api> <api to check>\n";
  exit 1;
}

# Read in the old and new APIs.
$orig = open_japi($origfile);
$new = open_japi($newfile);

# Open the appropriate thing for output. If we will be piping to japiohtml or
# japiotext, we first redirect STDOUT to whatever was given as "-o".
if ($outprog) {
  if ($opts{"o"}) {
    close STDOUT;
    open STDOUT, ">$opts{o}";
  }
  my $ct = 0; my $prog = $0;
  $prog = readlink $prog while -l $prog && $ct++ < 5;
  $progdir = $1 if $prog =~ /^(.*)\/[^\/]+$/;
  open OUT, "|$progdir/$outprog";
} else {
  if ($opts{"o"}) {
    open OUT, ">$opts{o}";
  } else {
    open OUT, ">-";
  }
}

# Loop through the two files and compare them.
compare_japis($orig, $new);

# Close out the files now we're done with them.
close_japi($orig);
close_japi($new);

# Merge the results into a single stream of errors, and print them to stdout.
merge_results();

# Print a summary of what was found.
print_summary();


## SUBROUTINES ##

# Compare two japi entries pseudo-alphabetically.
sub japicmp($$) {
  my ($ia, $ib) = @_;
  return -1 unless defined $ib;
  $ia->{rawitem} cmp $ib->{rawitem};
}

sub open_japi($) {
  my ($filename) = @_;
  my $japi;
  $japi->{name} = $filename;
  my $fh;
  if ($filename =~ /\.gz$/) {
    $fh = new IO::Pipe()->reader("gzip", "-dc", $filename);
    die "Could not pipe from gzip: $!" unless $fh;
  } else {
    $fh = new IO::File("<$filename");
    die "Could not open $filename: $!" unless $fh;
  }
  print STDERR "Loading $filename" if $dot;
  my $japiline = $fh->getline;
  chomp $japiline;
  die <<EOF unless $japiline =~ /^%\%japi ([^ ]*)(?: (.*))?$/;

This looks like an old-style japi file. The format was changed since version
0.7 to save disk space and avoid a theoretically possible ambiguity. Most
new japis are approx. 30% smaller than the coresponding old-style ones. It was
changed again since version 0.8 to allow japicompat to use smarter algorithms.
You can use japifix to convert to the new format.
EOF
  my ($filever, $info) = ($1, $2);
  die <<EOF if $filever lt $japiver;

This japi file claims to be version $filever, but this version of japicompat
only understands version $japiver. You can use japifix to upgrade old japi
files to version $japiver.
EOF
  die <<EOF if $filever gt $japiver;

This japi file claims to be version $filever, but this version of japicompat
only understands version $japiver. Either the japi file is incorrect or you need
a new version of japicompat.
EOF
  print STDERR ".\n" if $dot;
  $japi->{fh} = $fh;
  foreach my $infitem (split / /, $info) {
    my ($infname, $infvalue) = split /=/, $infitem, 2;
    $japi->{$infname} = $infvalue;
  }
  return $japi;
}

sub read_japi_item($) {
  my ($japi) = @_;
  my $fh = $japi->{fh};
  my $line = $fh->getline;
  return undef unless $line;
  chomp $line;
  
  # Parse and interpret the entry.
  my ($item, $flags, $type) = split / /, $line, 3;

  # Ensure that this item is correctly ordered.
  die "\nIncorrect ordering of $japi->{name}:\n$japi->{last_item} >=\n$item"
    if defined($japi->{last_item}) && $japi->{last_item} ge $item;
  $japi->{last_item} = $item;

  my $rawitem = $item;

  # Check and trim the leading plusses on java.lang.Object and java.lang.
  die "\nMissing required leading plusses on $item"
    if $item =~ /^java\.lang[.,]/ || $item =~ /^\+java\.lang,Object!/;
  $item =~ s/^\+\+java\.lang,Object!/java.lang,Object!/;
  $item =~ s/^\+java\.lang([.,])/java.lang$1/;
  die "\nIncorrect leading plusses on $item" if $item =~ /^\+/;

  my ($fqcn, $member) = split /!/, $item, 2;
  my ($pkg, $class) = split /,/, $fqcn, 2;
  my $isa;
  if ($member eq "") {
    $isa = $type =~ /^class/ ? "class" : "interface";
  } elsif ($member =~ /^\(.*\)$/) {
    $isa = "constructor";
  } elsif ($member =~ /\(.*\)$/) {
    $isa = "method";
  } elsif ($member =~ /^#(.*)$/) {
    $isa = "field";
    $member = $1;
  } else {
    die <<EOF;

Could not interpret item in japi file:
$line
Either this japi file is corrupt or you have uncovered a bug in japicompat.
Please email this error message in full to sballard\@netreach.net.
EOF
  }

  # Store information about the entry in $japi->{$pkg}->{$class}->{$member}.
  my $mitem = {};
  $mitem->{rawitem} = $rawitem;
  $mitem->{item} = $item;
  $mitem->{isa} = $isa;
  $mitem->{class} = $class;
  $mitem->{package} = $pkg;
  $mitem->{member} = $member;
  my ($public, $abstract, $static, $final, $deprecated) = split //, $flags;
  $mitem->{public} = ($public eq 'P' || 0);
  $mitem->{abstract} = ($abstract eq 'a' || 0);
  $mitem->{static} = ($static eq 's' || 0);
  $mitem->{final} = ($final eq 'f' || 0);
  $mitem->{deprecated} = ($deprecated eq 'd' ? 1 :
                          $deprecated eq 'u' ? 0 : undef);

  # Classes and interfaces have superclasses and implemented interfaces tacked
  # on to the "type" field. We store this information in the $japi hash also.
  if ($member eq "") {

    # Get the interfaces data, which is separated by '*'s from the classname.
    my @ifaces = split(/\*/, $type);
    $type = shift @ifaces;
    $mitem->{ifaces} = {};
    foreach my $iface (@ifaces) {
      $mitem->{ifaces}->{$iface} = 1;
    }

    # Get the class's superclasses, which are separated by ':'s.
    my @supers = split(/:/, $type);
    $type = shift @supers;
    my $ct = 0;
    $mitem->{supers} = [];
    foreach my $super (@supers) {
      $mitem->{superset}->{$super} = 1;
      $mitem->{supers}->[$ct++] = $super;
    }

    my $svuid;
    ($type, $svuid) = split(/#/, $type, 2);
    $mitem->{svuid} = $svuid if defined $svuid;

  # Methods and constructors have exceptions that can be thrown separated by
  # '*'s from the typename. These also need to get stored in the hash.
  } elsif ($member =~ /\(.*\)$/) {
    my @excps = split(/\*/, $type);
    $type = shift @excps;
    foreach my $excp (@excps) {
      $mitem->{excps}->{$excp} = 1;
    }
  # Fields can have their value separated by a : from the typename, if they
  # are constant.
  } else {
    my ($val, $bits);
    ($type, $val) = split(/:/, $type, 2);
    ($val, $bits) = ($1, $2)
      if ($type eq 'F'||$type eq 'D') && defined $val && $val =~ /^(.*)\/(.*)$/;
    $mitem->{constbits} = $bits if defined $bits;
    $mitem->{constant} = $val if defined $val;
  }

  # Store what's left of the type after parsing off all of those parts.
  $mitem->{type} = $type;

  return $mitem;
}

sub close_japi($) {
  my ($japi) = @_;
  my $fh = $japi->{fh};
  close $fh;
}

sub inc($$$$;$) {
  my ($c, $pkg, $isa, $etype, $count) = (@_, 1);
  $c->{"$pkg/$etype"} += $count;
  $c->{"#$isa/$etype"} += $count;
  $c->{"/$etype"} += $count;
}

sub output_error($$$$$$$;$) {
  my ($oitem, $nitem, $oclitem, $c, $etype, $was, $is, $count) = (@_, 1);
  print STDERR "Warning: output_error call unconverted ($was)\n" if $is =~ /^[0-9]+$/;
  my ($supct, $sups);
  if ($oitem->{isa} eq "package") {
    $supct = 0;
    $sups = "";
  } else {
    $supct = scalar @{$oclitem->{supers}} + keys %{$oclitem->{ifaces}};
    $supct++ unless $supct;
    $sups = join ";", @{$oclitem->{supers}}, keys %{$oclitem->{ifaces}};
  }
  unless ($ofhs[$supct]) {
    $ofhs[$supct] = new_tmpfile IO::File();
  }
  print {$ofhs[$supct]} "error $etype $oitem->{isa} $oitem->{item} $sups $was/$is\n";

  # Note that since svuid checking happens last, svuid error count will only
  # be inc'd if the item isn't already BAD for some other reason.
  inc($c, $oitem->{package}, $oitem->{isa}, $etype, $count)
    unless $errhere;
  $errhere = 1;
}

sub pct($$$$) {
  my ($c, $pkg, $etype, $str) = @_;
  my $ct = $c->{"$pkg/$etype"};
  return $str unless $ct;
  my $tot = $c->{"$pkg/total"};
  $str .= ", " if $str;
  return $str . ((int (10000 * $ct / $tot)) / 100) . "% $etype";
}

sub short_summary($$) {
  my ($c, $pkg) = @_;
  my $pkgn = $pkg || "Total";
  if ($pkg =~ /^#(.)(.*)$/) {
    $pkgn = uc($1) . $2;
    $pkgn .= "e" if $pkgn =~ /[sx]$/;
    $pkgn .= "s";
  }
  my $summ = pct($c, $pkg, "good", "");
  $summ = pct($c, $pkg, "minor", $summ);
  $summ = pct($c, $pkg, "bad", $summ);
  $summ = pct($c, $pkg, "missing", $summ);
  $summ = pct($c, $pkg, "abs.add", $summ);
  my $pkgc = $pkg || "#";
  print OUT "rawsummary $pkgc";
  foreach my $item ("good", "minor", "bad", "missing", "abs.add") {
    my $itm = $item;
    $itm = "+abs.add" if $item eq "abs.add";
    my $val = $c->{"$pkg/$item"};
    print OUT " $itm:$val" if $val;
  }
  print OUT "\n";
  print STDERR "\r$pkgn: $summ\n" if $dot;
}

# Loop through all the packages in the original API and process them.
sub compare_japis($$) {
  my ($orig, $new) = @_;

  my $origname = $origfile;
  my $newname = $newfile;
  $origname .= "\@$orig->{date}" if $orig->{date};
  $newname .= "\@$new->{date}" if $new->{date};

  print OUT "%\%japio 0.9.1 $origname $newname\n";
  print OUT "categories =good ";
  print OUT "=mi_nor " if $svuid_errors;
  print OUT "bad missing";
  print OUT " abs.add" unless $sun_only;
  print OUT "\n";
  my $pkg = "";
  my $class = "";
  my $c = {}; # counts
  my $oitem = read_japi_item($orig);
  my $nitem = read_japi_item($new);
  my ($oclitem, $nclitem);
  print STDERR "Comparing...\n" if $dot;
  while (defined $oitem) {
    inc($c, $oitem->{package}, $oitem->{isa}, "total");
    my $isnewpkg = ($pkg ne $oitem->{package});
    my $isnewclass = $isnewpkg || ($class ne $oitem->{class});
    my $cmp;
    my $first = 1;
    while (($cmp = japicmp($oitem, $nitem)) > 0) {
      $errhere = 0;

      # Keep an eye out for members that are abstract that are also not in
      # the original. This check is not in the JLS, so only do it if sun_only
      # is false.
      if (!$sun_only && !$first && $nitem->{abstract} &&
          $nitem->{package} eq $pkg && $nitem->{class} eq $class) {
        my $mtype = $nclitem->{isa} eq "class" ? "abstract" : $nclitem->{isa};
        output_error($nitem, $nitem, $oclitem, $c, "abs.add",
                     "", "new $mtype method");
      }
      $first = 0;
      $nitem = read_japi_item($new);
    }
    if ($isnewpkg) {
      short_summary($c, $pkg) if $pkg;
      print STDERR $oitem->{package} if $dot;
    }
    print STDERR $dot if $isnewclass;
    $pkg = $oitem->{package};
    $class = $oitem->{class};
    $oclitem = $oitem if $isnewclass;
    $errhere = 0;
    if ($cmp) {
      my $ecount = 1;
      my $eitem = {%$oitem};
      if ($isnewpkg && (!defined($nitem) ||
                        $nitem->{package} ne $oitem->{package})) {
        $eitem->{isa} = "package";
        $eitem->{class} = "";
        $eitem->{item} = "$pkg,!";
        while (defined $oitem && $oitem->{package} eq $pkg) {
          $oitem = read_japi_item($orig);
          if (defined $oitem && $oitem->{package} eq $pkg) {
            inc($c, $pkg, $oitem->{isa}, "total");
            $ecount++;
          }
        }
      } elsif ($isnewclass) {
        while (defined $oitem && $oitem->{package} eq $pkg &&
               $oitem->{class} eq $class) {
          $oitem = read_japi_item($orig);
          if (defined $oitem && $oitem->{package} eq $pkg &&
              $oitem->{class} eq $class) {
            inc($c, $pkg, $oitem->{isa}, "total");
            $ecount++;
          }
        }
      } else {
        $oitem = read_japi_item($orig);
      }
      output_error($eitem, undef, $oclitem, $c, "missing",
                   "", "missing", $ecount);
    } else {
      $nclitem = $nitem if $isnewclass;
      inc($c, $pkg, $oitem->{isa}, "good")
        unless compare_japi_item($oitem, $nitem, $oclitem, $c);
      $oitem = read_japi_item($orig);
    }
  }

  # New abstract members in a class might show up even at the end of the file,
  # after the last item in orig.
  my $first = 1;
  while (!$sun_only && defined $nitem &&
         $nitem->{package} eq $pkg && $nitem->{class} eq $class) {
    $errhere = 0;

    # Keep an eye out for members that are abstract that are also not in
    # the original. This check is not in the JLS, so only do it if sun_only
    # is false.
    if (!$first && $nitem->{abstract}) {
      my $mtype = $nclitem->{isa} eq "class" ? "abstract" : $nclitem->{isa};
      output_error($nitem, $nitem, $oclitem, $c, "abs.add",
                   "", "new $mtype method");
    }
    $first = 0;
    $nitem = read_japi_item($new);
  }
  short_summary($c, $pkg) if $pkg;
  short_summary($c, "");
}

sub compare_japi_item($$$$) {
  my ($oitem, $nitem, $oclitem, $c) = @_;

  my $isa = $oitem->{isa};
  my $member = $oitem->{member};

  # Check that access to the item hasn't been reduced.
  if ($oitem->{public} && !$nitem->{public}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "public", "protected");
  }

  # Check that the item hasn't changed from concrete to abstract.
  if (!$oitem->{abstract} && $nitem->{abstract}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "concrete", "abstract");
  }

  # Check that the staticness of the item hasn't changed
  if ($oitem->{static} != $nitem->{static}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 $static[$oitem->{static}], $static[$nitem->{static}]);
  }

  # Check that the item hasn't gone from nonfinal to final, except
  # for static methods.
  if (!$oitem->{final} && $nitem->{final} &&
      ($oitem->{isa} ne "method" || !$oitem->{static})) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "nonfinal", "final");
  }

  # Check that the item's type has remained the same.
  if ($oitem->{type} ne $nitem->{type}) {
    unless ($oitem->{isa} eq "field" && $oitem->{type} !~ /:/ &&
            $nitem->{type} =~ /^\Q$oitem->{type}\E:/) {
      output_error($oitem, $nitem, $oclitem, $c, "bad",
                   "type @{[sig2type($oitem->{type})]}", "type @{[sig2type($nitem->{type})]}");
      # Do I win the award for "most consecutive close brackets"?
    }
  }

  # For classes and interfaces, check that nothing has been removed from
  # the set of super-interfaces or superclasses.
  if ($member eq "") {
    foreach my $iface (keys %{$oitem->{ifaces}}) {
      unless ($nitem->{ifaces}->{$iface}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "implements $iface", "doesn't implement $iface");
      }
    }
    my $super = $oitem->{supers}->[0];
    if (defined $super and !$nitem->{superset}->{$super}) {
      output_error($oitem, $nitem, $oclitem, $c, "bad",
                   "subclass of $super", "not a subclass of $super");
    }

    # Also check the SerialVersionUID if that is turned on.
    if ($svuid_errors && defined $oitem->{svuid}) {
      if (!defined $nitem->{svuid}) {
        output_error($oitem, $nitem, $oclitem, $c, "minor",
                     "SerialVersionUID=$oitem->{svuid}", "no SVUID");
      } elsif ($nitem->{svuid} ne $oitem->{svuid}) {
        output_error($oitem, $nitem, $oclitem, $c, "minor",
                     "SerialVersionUID=$oitem->{svuid}", "SerialVersionUID=$nitem->{svuid}");
      }
    }
    if ($svuid_errors && defined $oitem->{deprecated} &&
        defined $nitem->{deprecated}) {
      if ($oitem->{deprecated} && !$nitem->{deprecated}) {
        output_error($oitem, $nitem, $oclitem, $c, "minor",
                     "deprecated", "not deprecated");
      }
    }

  # For methods and constructors, check that the set of thrown exceptions
  # is the same. The JLS does not specify this so only do it if not
  # sun_only.
  } elsif ($member =~ /\(.*\)/ && !$sun_only) {
    foreach my $excp (keys %{$oitem->{excps}}) {
      unless ($nitem->{excps}->{$excp}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "throws $excp", "doesn't throw $excp");
      }
    }
    foreach my $excp (keys %{$nitem->{excps}}) {
      unless ($oitem->{excps}->{$excp}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "doesn't throw $excp", "throws $excp");
      }
    }

  # For fields, check the constant value if there is one.
  } else {
    if (defined $oitem->{constant}) {
      if (!defined $nitem->{constant}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "constant [$oitem->{constant}]", "nonconstant");
      } elsif ($nitem->{constant} ne $oitem->{constant}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "constant [$oitem->{constant}]", "constant [$nitem->{constant}]");
      }
    }
  }

  return $errhere;
}

sub merge_results() {
  my $errs = {};
  $sc = {};
  print STDERR "Merging results / eliminating duplicates...\n" if $dot;
  foreach my $fh (@ofhs) {
    if ($fh) {
      $fh->seek(0, 0);
      while (<$fh>) {
        chomp;
        my $line = $_;
        my ($error, $etype, $isa, $item, $sups, $rest) = split(/ /, $_, 6);
        my ($class, $member) = split(/!/, $item, 2);
        my @sups = split(/;/, $sups);
        my $insup = 0;

        # Determine whether the same error appears in any superclass, and if so
        # do not report this error. That doesn't apply, though, to missing
        # classes, which should be reported regardless of whether their
        # superclass is missing too. It also doesn't apply to errors in
        # constructors, since they aren't inherited.
        unless ((($isa eq 'class' || $isa eq 'interface') &&
                 $etype eq 'missing') ||
                $isa eq 'constructor') {
          foreach my $sup (@sups) {
            $insup = 1 if $errs->{"$sup\!$member $rest"};
          }
        }
        unless ($insup) {
          my ($pkg, $cls) = split(/,/, $class, 2);
          $class = "$pkg.$cls";
          $errs->{"$class\!$member $rest"} = 1;
          print OUT "$line\n";
          $totalerrors++;
          inc($sc, $pkg, $isa, $etype);
        }
      }
      $fh->close();
      undef $fh;
    }
  }
  print STDERR "Done.\n" if $dot;
}

sub ct($$$$) {
  my ($c, $pkg, $etype, $str) = @_;
  my $ct = $c->{"$pkg/$etype"};
  return $str unless $ct;
  $str .= ", " if $str;
  return "$str$ct $etype";
}

sub count_summary($$) {
  my ($c, $pkg) = @_;
  my $pkgn = $pkg || "Total";
  if ($pkg =~ /^#(.)(.*)$/) {
    $pkgn = uc($1) . $2;
    $pkgn .= "e" if $pkgn =~ /[sx]$/;
    $pkgn .= "s";
  }
  my $summ = ct($c, $pkg, "good", "");
  $summ = ct($c, $pkg, "minor", $summ);
  $summ = ct($c, $pkg, "bad", $summ);
  $summ = ct($c, $pkg, "missing", $summ);
  $summ = ct($c, $pkg, "abs.add", $summ);
  $summ = "All good" unless $summ;
  print STDERR "\r$pkgn: $summ \n" if $dot;
}
# Print summary information.
sub print_summary() {
  print STDERR "\n" if $dot;
  count_summary($sc, "#package");
  count_summary($sc, "#class");
  count_summary($sc, "#interface");
  count_summary($sc, "#field");
  count_summary($sc, "#constructor");
  count_summary($sc, "#method");
  print STDERR "$totalerrors unique errors found.\n" if $dot;
}
# Convert a type signature as used in a japi file to a displayable type.
sub sig2type($) {
  my ($sig) = @_;
  return sig2type($1) . '[]' if $sig =~ /^\[(.*)$/;
  return $javatypes->{$sig} if $javatypes->{$sig};
  if ($sig =~ /^L(.*);$/) {
    $sig = $1; $sig =~ s-/-.-g;
  }
  $sig;
}
