#!/usr/bin/perl

use IO::Handle;
use Getopt::Std;

%sigs = (boolean=>'Z', byte=>'B', char=>'C', double=>'D', float=>'F', int=>'I',
         long=>'J', short=>'S', void=>'V',
         class=>'class', interface=>'interface', constructor=>'constructor');

sub out($);
sub begin();
sub start();
sub dump_deferred();
sub finish();
sub to_new();
sub scmp(&;&);

my @out = ();

while (begin) {
  $_ = <IN>; chomp;
  if (/^[^ ]+#[^ ]* (public|protected) (abstract|concrete) (static|instance) (final|nonfinal) /) {
    $japiver = "0.7";
    start;
    out to_new;
  } elsif (/^[^ ]+#[^ ]* [Pp][ac][si][fn] /) {
    $japiver = "0.8";
    start;
    out to_new;
  } elsif (/^\%\%japi ([^ ]*)(?: .*)?$/) {
    $japiver = $1;
    if ($japiver ne "0.8.1" && $japiver ne "0.9") {
      print STDERR <<EOF;
This japi file claims to be version $japiver, but this version of japi2new only
understands version 0.8.1, version 0.9, and older versions that did not carry a
version number. Either this japi file is incorrect or you need a newer version
of japi2new.
EOF
      exit 1;
    }
    start;
  } else {
    print STDERR <<EOF;
This does not appear to be a japi file. japi2new can only update old japis,
not create them from scratch.
EOF
    exit 1;
  }

  while(<IN>) {
    chomp;
    out to_new;
  }
  finish;
}

sub out($) {
  if ($needtosort || $defer_output) {
    push @out, "$_[0]\n";
  } else {
    print OUT "$_[0]\n";
  }
}

sub begin() {
  #: check if there's any more to do; return false if not
  return 0 unless @ARGS;

  #: parse parameters
  getopts("zubo:g:", \%opts);

  # -z|-u -b -o[file]|-g[file]|[file1 ...]
  # -z to zip output, -u to unzip output (default is to follow the input file
  # unless it's too old to have been zipped itself, in which case zip it)
  # -b to NOT back up the original file with a .bak extension. Original file
  # will be removed instead. Doesn't apply to -o/-g mode.
  # -o to read unzipped input from stdin and output to [file] or stdout
  # -g to read gzipped input from stdin and output to [file] or stdout
  # all other args are japi files to convert; output is to original filename
  # (plus or minus .gz); original will be renamed to .bak.
  #: open IN
  #: open OUT
  #: return true
}

sub start() {
  $needtosort = $japiver le "0.8";
  print STDERR "Converting from japi version $japiver...";
  STDERR->autoflush;
  print OUT "%\%japi 0.9\n";
}

sub dump_deferred() {
  if (@out) {
    print STDERR " (relocated java.lang)";
    print OUT @out;
    @out = ();
  }
}

sub finish() {
  if ($needtosort) {
    print STDERR " sorting...";
    print OUT (sort {scmp {/^java\.lang,Object%/},
                sub {scmp {/^java\.lang,/}}} @out);
  }
  #: close IN
  #: move new file to overwrite old, if necessary
  shift;
  print STDERR " done.\n";
}

sub to_new() {

  my $older = 0;
  if ($japiver == "0.7" or $older) {
    $older = 1;

    # Parse and interpret the entry.
    my ($item, $access, $abstract, $static, $final, $type) = split / /, $_, 6;

    # We need to convert the modifier string and all the type signatures to
    # japi v0.8 format.

    # If it's a method or constructor, convert the typesigs and store the result
    # in $class and $member.
    my ($class, $member) = split /#/, $item, 2;
    if ($member =~ /^(.*)\((.*)\)$/) {
      my ($nm, $params) = ($1, $2);
      my @params = split(/,/, $2);
      $params = join(',', map { type2sig($_) } @params);
      $member = "$nm($params)";
    }

    # Extract the parts of 'type' that actually do constitute the type, convert
    # its typesig and then put it back together with the other information.
    my ($tp, $bits) = ($1, $2) if $type =~ /^([^#:*]+)((?:[#:*].*)?)$/;
    $type = type2sig($tp) . $bits;

    # Convert the modifiers into the shortened, 4 character (instead of 4 word)
    # string.
    my $flags = ($access eq 'public' ? 'P' : 'p');
    $flags .= ($abstract eq 'abstract' ? 'a' : 'c');
    $flags .= ($static eq 'static' ? 's' : 'i');
    $flags .= ($final eq 'final' ? 'f' : 'n');

    # Put it all back together into a japi entry and push it.
    $_ = "$class#$member $flags $type";
  }
  if ($japiver eq "0.8" or $older) {
    $older = 1;
    if (
      /^(?:((?:[a-zA-Z0-9_]+\.)*[a-zA-Z0-9_]+)\.)?([a-zA-Z0-9_\$]+)#([^ ]*) (.*)$/
        ) {
      my ($pkg, $class, $member, $rest) = ($1, $2, $3, $4);
      $member = "#$member" if $member =~ /^[^()]+$/;
      $_ = "$pkg,$class%$member $rest";
    } else {
      print STDERR "Unknown line: $_\n";
      exit 1;
    }
  }
  if ($japiver eq "0.8.1" or $older) {
    $older = 1;
    unless ($needtosort) {
      $defer_output = !$past_jlo && !/^java\.lang,/;
      dump_deferred if $past_jlo && !/^java\.lang,/;
      $past_jlo = 1 if /^java\.lang,/ && !/^java\.lang,Object%/;
    }
  }
  if ($japiver eq "0.9" or $older) {
    $older = 1;
    # Do nothing - 0.9 is as far as we can get right now...
  }
  return $_;
}

# Function for doing complicated comparisons. Returns a value equivalent to
# that returned by cmp. Takes 2 arguments: a function which tests whether $_ is
# in the 'preferred' set and a function to fall back on if neither or both are
# in the preferred set. The fallback function is called using a and b, as usual,
# and defaults to {$a cmp $b}.
sub scmp(&;&) {
  my ($prf, $flbk) = (@_, sub {$a cmp $b});
  $_ = $a; my $aprf = &$prf();
  $_ = $b; my $bprf = &$prf();
  $aprf && !$bprf ? -1 :
  $bprf && !$aprf ? 1 :
  &$flbk();
}

# Convert a pre-0.8 semi-human-readable typename into a 0.8-and-above JVM-style
# type signature.
sub type2sig($) {
  my ($type) = @_;
  return $sigs{$type} if $sigs{$type};
  $type =~ s-\.-/-g;
  $type =~ /^\[/ ? $type : "L$type;";
}
