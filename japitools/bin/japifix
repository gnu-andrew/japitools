#!/usr/bin/perl

use IO::Handle;
use Getopt::Std;
use integer;

%sigs = (boolean=>'Z', byte=>'B', char=>'C', double=>'D', float=>'F', int=>'I',
         long=>'J', short=>'S', void=>'V',
         class=>'class', interface=>'interface', constructor=>'constructor');

%excp_supers = ();

sub out($);
sub begin();
sub start();
sub dump_deferred();
sub finish();
sub to_new();
sub jcmp();
sub printusage();

my @out = ();

my $progname = $1 if $0 =~ /(?:.*\/)?([^\/]+)/;
MAIN: while (begin) {
  my $line;
  while(<IN>) {
    chomp;
    next MAIN unless out to_new;
  }
  finish;
}

sub out($) {
  return 1 if $scan_only && $needtosort;
  return 0 if $dump_deferred && !dump_deferred;
  $dump_deferred = 0;
  if (!$needtosort && (($defer_output && @out) || defined $last_out)) {
    if ($defer_output && @out) {
      $a = $out[$#out];
    } else {
      $a = $last_out;
    }
    $b = $_[0];
    if (jcmp >= 0) {
      if ($scan_only) {
        print STDERR "\n$infile mis-sorted:\n$a >=\n$b\nWill enable sort..."
          unless $sortthis;
        $sortthis = 1;
      } else {
        unshift @ARGV, $infile;
        print STDERR "\n$infile mis-sorted:\n$a >=\n$b\nRestarting with sort enabled\n";
        $sortthis = 1;
        return 0;
      }
    }
  }
  if ($needtosort) {
    # Certain versions of perl use sort algorithms that are subject to
    # pathological behavior for nearly-sorted data. Since that kind of data
    # crops up often in japi files, we randomize the order of data being added
    # to @out.
    if (@out) {
      my $rnd = int rand scalar @out;
      push @out, $out[$rnd];
      $out[$rnd] = "$_[0]\n";
    } else {
      push @out, "$_[0]\n";
    }
  } elsif ($defer_output) {
    push @out, "$_[0]\n";
  } else {
    print OUT "$_[0]\n" unless $scan_only;
  }
  $last_out = $_[0] unless $needtosort;
  return 1;
}

sub dump_deferred() {
  if (@out && !$needtosort) {
    print STDERR " (relocated java.lang)" unless $scan_only;
    if (defined $last_out) {
      $a = $last_out;
      $b = $out[0];
      if (jcmp >= 0) {
        if ($scan_only) {
          print STDERR "\n$infile mis-sorted:\n$a >=\n$b\nWill enable sort..."
            unless $sortthis;
          $sortthis = 1;
        } else {
          unshift @ARGV, $infile;
          print STDERR "\n$infile mis-sorted:\n$a >=\n$b\nRestarting with sort enabled\n";
          $sortthis = 1;
          return 0;
        }
      }
    }
    print OUT @out unless $scan_only;
    $last_out = @out[$#out];
    @out = ();
  }
  return 1;
}

sub begin() {

  #: check if there's any more to do; return false if not
  return 0 unless @ARGV || $firsttime;

  $last_out = undef;

  #: parse parameters
  my $firsttime = 1 unless defined %opts;
  getopts("hzube:", \%opts) if $firsttime;

  printusage if $opts{h};
  my $zippit = 1 if $opts{z};
  my $unzippit = 1 if $opts{u};
  my $backup = 1 unless $opts{b};

  if ($firsttime && $opts{e}) {
    my @excpfiles = split /,/, $opts{e};
    unshift @ARGV, @excpfiles;
    $excpfiles = $#excpfiles + 1;
  }

  printusage if $zippit && $unzippit;

  # $infile and $outfile are global, deliberately
  $infile = $outfile = undef;
  my $zin;

  unless (@ARGV) {
    printusage unless $firsttime;
    exit 0;
  }

  $infile = shift @ARGV;
  die "$progname cannot work on stdin" if $infile eq "-";

  $zin = 1 if $infile =~ /\.gz$/;
  $outfile = "$1.japi" if $infile =~ /^(.*?)(?:\.japi)?(?:\.gz)?$/;

  if ($zin) {
    if (!open IN, "-|") {
      exec "gzip", "-dc", $infile or die "Couldn't exec gzip: $!";
    }
  } else {
    open IN, "<$infile" or die "Cannot open $infile: $!";
  }

  $_ = <IN>; chomp;
  if (/^[^ ]+#[^ ]* (public|protected) (abstract|concrete) (static|instance) (final|nonfinal) /) {
    $japiver = "0.7";
  } elsif (/^[^ ]+#[^ ]* [Pp][ac][si][fn] /) {
    $japiver = "0.8";
  } elsif (/^\%\%japi ([^ ]*)(?: .*)?$/) {
    $japiver = $1;
    if ($japiver ne "0.8.1" && $japiver ne "0.9" && $japiver ne "0.9.1" &&
        $japiver ne "0.9.2") {
      print STDERR <<EOF;
This japi file claims to be version $japiver, but this version of $progname only
understands versions 0.8.1, 0.9, 0.9.1, 0.9.2, and older versions that did not
carry a version number. Either this japi file is incorrect or you need a newer
version of $progname.
EOF
      exit 1;
    }
  } else {
    print STDERR <<EOF;
This does not appear to be a japi file. $progname can only update old japis,
not create them from scratch.
EOF
    exit 1;
  }

  %init_supers = %excp_supers if ($is_excpfile);

  if ($excpfiles) {
    $excpfiles--;
    $scan_only = 1;
    $is_excpfile = 1;
  } elsif ($japiver le "0.9.1") {
    if ($scan_only) {
      $scan_only = 0;
      print " done.\n";
    } else {
      $scan_only = 1;
      %excp_supers = %init_supers;
      unshift @ARGV, $infile;
    }
    $is_excpfile = 0;
  } else {
    $scan_only = 0;
    %excp_supers = %init_supers;
    $is_excpfile = 0;
  }
  unless ($scan_only) {
    my $zout = $zippit ? 1 : $unzippit ? 0 : $japiver le "0.8" ? 1 : $zin;
    $backupfile = $rename = undef;
    $backupfile = $infile if $backup;

    $outfile = "$outfile.gz" if $zout;
    my $outfile_new = $rename = "$outfile.new";

    if ($zout) {
      if (!open OUT, "|-") {
        open STDOUT, ">$outfile_new";
        exec "gzip", "-c" or die "Couldn't exec gzip: $!";
      }
    } else {
      open OUT, ">$outfile_new" or die "Cannot open $outfile_new: $!";
    }
  }
  start;
  out to_new if $japiver le "0.8";
  $dump_deferred = 0;

  return 1;
}

sub printusage() {
  print <<EOF;
Usage: $progname -z|-u -b [-e ex1,ex2] file1 ...
   -h to display this help message.
   -z to zip output, -u to unzip output (default is to follow the input file
   unless it's too old to have been zipped itself, in which case zip it)
   -b to NOT back up the original file with a .bak extension. Original file
   will be overwritten unless filename is different (eg due to ".gz" extension).
   -e to provide a comma-separated list of japi files covering any exceptions
   that are thrown by methods in japi files to convert, but aren't actually
   included in the same japi. $progname needs to know the superclass of every
   thrown exception: if you throw IOException, you need to provide a japi that
   defines IOException by using the -e option.
   All other args are japi files to convert; output is to original filename
   (plus or minus .gz); original will be renamed to .bak.
EOF
  exit 1;
}

sub start() {
  $needtosort = $japiver le "0.8" || $sortthis;
  $sortthis = 0;
  print STDERR $scan_only ?
    "Scanning $outfile (japi v$japiver) for exception types..." :
    "Converting $outfile (japi v$japiver)...";
  STDERR->autoflush;
  @out = ();
  print OUT "%\%japi 0.9.2\n" unless $scan_only;
}

sub finish() {
  if ($scan_only) {
    close IN;
    return;
  }
  if ($needtosort) {
    print STDERR " sorting...";
    print OUT (sort jcmp @out);
  }
  close IN;
  close OUT;
  if (defined $backupfile) {
    rename $backupfile, "$backupfile.bak"
      or die "\nCould not create $backupfile.bak: $!";
  }
  if (defined $rename) {
    rename $rename, $outfile or die "\nCould not rename $rename to $outfile: $!";
  }
  print STDERR " done.\n";
}

sub to_new() {

  my $older = 0;
  if ($japiver eq "0.7" or $older) {
    $older = 1;

    # Parse and interpret the entry.
    my ($item, $access, $abstract, $static, $final, $type) = split / /, $_, 6;

    # We need to convert the modifier string and all the type signatures to
    # japi v0.8 format.

    # If it's a method or constructor, convert the typesigs and store the result
    # in $class and $member.
    my ($class, $member) = split /#/, $item, 2;
    if ($member =~ /^(.*)\((.*)\)$/) {
      my ($nm, $params) = ($1, $2);
      my @params = split(/,/, $2);
      $params = join(',', map { type2sig($_) } @params);
      $member = "$nm($params)";
    }

    # Extract the parts of 'type' that actually do constitute the type, convert
    # its typesig and then put it back together with the other information.
    my ($tp, $bits) = ($1, $2) if $type =~ /^([^#:*]+)((?:[#:*].*)?)$/;
    $type = type2sig($tp) . $bits;

    # Convert the modifiers into the shortened, 4 character (instead of 4 word)
    # string.
    my $flags = ($access eq 'public' ? 'P' : 'p');
    $flags .= ($abstract eq 'abstract' ? 'a' : 'c');
    $flags .= ($static eq 'static' ? 's' : 'i');
    $flags .= ($final eq 'final' ? 'f' : 'n');

    # Put it all back together into a japi entry and push it.
    $_ = "$class#$member $flags $type";
  }
  if ($japiver eq "0.8" or $older) {
    $older = 1;
    if (
      /^(?:((?:[a-zA-Z0-9_]+\.)*[a-zA-Z0-9_]+)\.)?([a-zA-Z0-9_\$]+)#([^ ]*) (.*)$/
        ) {
      my ($pkg, $class, $member, $rest) = ($1, $2, $3, $4);
      $member = "#$member" if $member =~ /^[^()]+$/;
      $_ = "$pkg,$class%$member $rest";
    } else {
      print STDERR "Unknown line: $_\n";
      exit 1;
    }
  }
  if ($japiver eq "0.8.1" or $older) {
    $older = 1;
    unless ($needtosort) {
      $defer_output = !$past_jlo && !/^java\.lang,/;
      $dump_deferred = $past_jlo && !/^java\.lang,/;
      $past_jlo = 1 if /^java\.lang,/ && !/^java\.lang,Object%/;
    }
  }
  if ($japiver eq "0.9" or $older) {
    $older = 1;
    my ($class, $rest) = split /%/, $_, 2;
    $_ = "$class!$rest";
  }
  if ($japiver eq "0.9.1" or $older) {
    $older = 1;
    if (!$scan_only) {
      my ($member, $rest) = split / /, $_, 2;
      if ($member =~ /\(.*\)$/) {
        my ($firstpart, $excps) = split /\*/, $_, 2;
        my @excps = split /\*/, $excps;
        for (my $exct = 0; $exct <= $#excps; $exct++) {
          if (include_exception(\@excps, $exct)) {
            $firstpart .= "*$excps[$exct]";
          }
        }
        $_ = $firstpart;
      }
    }
  }
  if ($japiver eq "0.9.2" or $older) {
    $older = 1;
    # Do nothing - 0.9.2 is as far as we can get right now...
  }

  # For ALL versions, we extract the exceptions in scan-only mode. This allows
  # any japi version to be passed in the -e option.
  if ($scan_only) {
    my ($member, $mods, $type) = split / /, $_, 3;
    if ($member =~ /!$/ && $type =~ /:java\.lang\.Throwable/) {
      my $sups = "$1$2" if /^([^!]+)![^:]+(:[^*]+)/;
      $sups =~ s/,/./;
      my @classes = split /:/, $sups;
      for (my $i = 1; $i <= $#classes; $i++) {
#       print "\n$classes[$i-1] => $classes[$i]" unless $excp_supers{$classes[$i-1]};
        $excp_supers{$classes[$i-1]} = $classes[$i];
      }
    }
  }
  return $_;
}

sub include_exception($$) {
  my ($excps, $index) = @_;
  my $is_super = 0;
  my ($lsupname, $lsupname);
  for ($supname = $excps->[$index];
       defined $supname && $supname ne "java.lang.Object";
       $supname = $excp_supers{$supname}) {
    return 0 if "java.lang.RuntimeException" eq $supname ||
                "java.lang.Error" eq $supname;
    if ($is_super) {
      for (my $i = 0; $i <= $#excps; $i++) {
        return 0 if $i != $index && $supname eq $excps->[$i];
      }
    }
    $is_super = 1;
    $lsupname = $supname;
#   print STDERR "\n$supname => $excp_supers{$supname}";
  }
  die "Could not identify superclass of $lsupname, try the -e option"
    unless defined $supname;
  return 1;
}

sub jcmp() {
  $ajlo = ($a =~ /^java\.lang,Object!/) ? -1 : 0;
  $bjlo = ($b =~ /^java\.lang,Object!/) ? -1 : 0;
  return $ajlo - $bjlo if $ajlo != $bjlo;
  $ajl = ($a =~ /^java\.lang[\.,]/) ? -1 : 0;
  $bjl = ($b =~ /^java\.lang[\.,]/) ? -1 : 0;
  ($ajl != $bjl) ? $ajl - $bjl : $a cmp $b;
}

# Convert a pre-0.8 semi-human-readable typename into a 0.8-and-above JVM-style
# type signature.
sub type2sig($) {
  my ($type) = @_;
  return $sigs{$type} if $sigs{$type};
  $type =~ s-\.-/-g;
  $type =~ /^\[/ ? $type : "L$type;";
}
