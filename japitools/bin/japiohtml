#!/usr/bin/perl -w
###############################################################################
# japiohtml - Convert japicompat output to pretty html format.
# Copyright (C) 2000-2002  Stuart Ballard <sballard@netreach.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################

## GLOBAL VARIABLES ##

# Some global variables used for displaying stuff.
$japiover = "0.9.1";

# Requirements
#use IO::Handle;

my $verline = <>;
chomp $verline;
($filever, $orig, $new) = ($1, $2, $3)
    if $verline =~ /^%\%japio ([^ ]+) ([^ ]+) ([^ ]+)(?: .*)?$/;
unless (defined $filever) {
  print STDERR <<EOF;
This does not look like a japio file.
EOF
  exit 1;
}
if ($filever ne $japiover) {
  print STDERR <<EOF;
This japio file claims to be version $filever, but this version of japiotext
only supports version $japiover.
EOF
  exit 1;
}

$orig =~ s/\.gz$//;
$orig =~ s/\.japi$//;
$new =~ s/\.gz$//;
$new =~ s/\.japi$//;
my $date = gmtime() . " GMT";

print <<EOF;
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
               "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>Results of comparison between $orig and $new</title>
    <link rel="stylesheet" type="text/css" href="japi.css">
  </head>
  <body>
    <h1>Results of comparison between $orig and $new</h1>
    <p class="datestamp">Comparison run at $date</p>
    <h2>Summary</h2>
    <p>Note that summary information is calculated prior to filtering the
       results (for duplicates, etc). It is possible to show a non-zero "bad" or
       "missing" score without any actual errors being listed.</p>
    <table class="summary" border="0" cellspacing="0" cellpadding="3">
EOF

my $alt = 1;
while (<>) {
  chomp;
  if (/^categories (.*)$/) {
    print <<EOF;
      <tr class="colhead">
        <td>&nbsp;</td>
EOF
    my @bits = split / /, $1;
    foreach my $bit (@bits) {
      if ($bit =~ /^(=?)(.)(.*)/) {
        push @categories, "$2$3";
        $okcats->{"$2$3"} = 1 if $1;
        my $capegory = uc($2).$3;
        my $cat = "$2$3"; $cat =~ s/\./-/g;
        print <<EOF;
        <th class="$cat">$capegory</th>
EOF
      }
    }
    print <<EOF;
      </tr>
EOF
  } elsif (/^rawsummary (.*)$/) {
    die "No categories line found before rawsummary line" unless @categories;
    my @bits = split / /, $1;
    my ($extra, $total, $values, $etotal, $oktotal) = ({}, 0, {}, 0, 0);
    my $pkg = shift @bits;
    foreach my $bit (@bits) {
      my ($plus, $key, $value) = ($1, $2, $3)
        if $bit =~ /^(\+?)([^:+]+):([0-9]+)$/;
      $etotal += $value;
      $oktotal += $value if $okcats->{$key};
      if ($plus) {
        $extra->{$key} = $value + 0;
      } else {
        $total += $value;
        $values->{$key} = $value + 0;
      }
    }
    my $pkgn = $pkg;
    if ($pkg eq "#") {
      print "\n";
      $pkgn = "Total";
    } elsif ($pkg =~ /^#(.)(.*)$/) {
      $pkgn = uc($1) . $2;
      $pkgn .= "e" if $pkgn =~ /[sx]$/;
      $pkgn .= "s";
    }
    my $pctclass = "none";
    $pctclass = (int($oktotal * 10 / $etotal) * 10)."pct" if $oktotal;
    print <<EOF;
      <tr class="alternating-$alt">
        <th class="ok-$pctclass">$pkgn:</th>
EOF
    $alt = 3 - $alt;
    foreach my $key (@categories) {
      my $val = "&nbsp;";
      if ($values->{$key}) {
        $val = (int($values->{$key} * 10000 / $total)/100) . "%";
      } elsif ($extra->{$key}) {
        $val = (int($extra->{$key} * 10000 / $total)/100) . "%";
      }
      my $class = $key; $class =~ s/\./-/g;
      print <<EOF;
        <td class="$class">$val</td>
EOF
    }

    use integer;

    # Now we need to integerize the percentages so we can emit a table whose
    # width (minus the "extra" bit) adds up to exactly 100 pixels. We also want
    # to ensure that *anything* nonzero gets at least a pixel. See the file
    # design/percent-rounding.txt for a justification of this algorithm.

    # Start off assuming nothing's less than 1%, and iterate until we find
    # that we're right. m is the number of adjustable (<1%) items, and t is
    # the total of the non-adjustable items. Lastm keeps track of what we
    # thought m was last time round. We loop until we do an entire pass without
    # m ending up different from lastm. Lastm starts off as -1 just so that the
    # m == lastm test fails first time around.
    my $t = $total;
    my $m = 0;
    my $lastm = -1;
    my $adjustable = {};
    until ($m == $lastm) {
      $lastm = $m;

      # Loop over the items that haven't already been marked adjustable. For
      # each such item, determine whether it needs to be adjustable based on
      # the current values of m and t. If it does, mark it as adjustable and
      # update m and t accordingly.
      foreach my $item (keys %$values) {
        if (!$adjustable->{$item}) {
          if ($values->{$item} * (100-$m) < $t) {
            $t -= $values->{$item};
            $m++;
            $adjustable->{$item} = 1;
          }
        }
      }
    }

    # Having calculated the final values of m and t, and also knowing exactly
    # which items are adjustable, we can now calculate the adjusted totals.
    # Non-adjustable items are scaled up by a constant factor; adjustable
    # items are all set to exactly 1% of the scaled total.
    my $adjtotal = 100 * $t;
    my $adjvalue = {};
    foreach my $item (keys %$values) {
      if ($adjustable->{$item}) {
        $adjvalue->{$item} = $t;
      } else {
        $adjvalue->{$item} = $values->{$item} * (100-$m);
      }
    }
       
    # Calculate the percentage rounded *down* to the nearest integer, and also
    # calculate the magnitude of the difference between the integer percentage
    # and the actual percentage. This is still all done in integer math...
    # While we're at it, sum the percentages so we can see how close we got,
    # later.
    my $totalpct = 0;
    my $percent = {};
    my $diff = {};
    foreach my $item (keys %$values) {
      $percent->{$item} = ($adjvalue->{$item} * 100) / $adjtotal;
      $diff->{$item} = $adjvalue->{$item} * 100 - $percent->{$item} * $adjtotal;
      $totalpct += $percent->{$item};
    }

    # Find the items with the largest differences, and adjust them upwards,
    # until 100% is reached. No need to reset the difference since we're looping
    # through the items and will never repeat: it's easy to show that the upper
    # bound on the number of upwards adjustments needed is smaller than the
    # number of items.
    foreach my $item (sort { $diff->{$b} <=> $diff->{$a} } keys %$values) {
      last if ($totalpct >= 100);
      $percent->{$item}++;
      $totalpct++;
    }

    foreach my $item (keys %$extra) {
      $percent->{$item} = ($extra->{$item} * 1000 + 5) / ($total * 10);
      $percent->{$item} = 1 unless $percent->{$item};
      $totalpct += $percent->{$item};
    }

    print <<EOF;
        <td>
          <table width="$totalpct" cellpadding="0" cellspacing="0" class="bar">
            <tr>
EOF
    foreach my $item (@categories) {
      if (exists $percent->{$item}) {
        my $pct = $percent->{$item};
        my $class = $item; $class =~ s/\./-/g;
        my $altc = uc(substr($item,0,1));
        my $alt = $altc x ($percent->{$item} / 5);
        $alt = $altc unless $alt;
        print <<EOF if $pct;
              <td width="$pct" class="$class-bar">
                <img src="1x1.gif" width="1" height="1" alt="$alt">
              </td>
EOF
      }
    }
    print <<EOF;
            </tr>
          </table>
        </td>
      </tr>
EOF
  } elsif (/^error (.*)$/) {
    print <<EOF unless $finishedsummary;
    </table>
    <h2>Errors</h2>
    <ul>
EOF
    $finishedsummary = 1;
    my ($etype, $isa, $item, $sups, $rest) = split / /, $1, 5;
    my ($was, $is) = split /\//, $rest;
    $etype =~ s/\./-/g;
    my $msg = $was ? "$was in $orig, but" : "";
    print <<EOF;
      <li class="$etype">$isa $item: $msg $is in $new</li>
EOF
  } else {
    die "Line not understood in japio file:\n$_";
  }
}
print <<EOF;
    </ul>
  </body>
</html>
EOF
exit 0;
