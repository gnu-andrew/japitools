#!/usr/bin/perl -w
###############################################################################
# japiohtml - Convert japicompat output to pretty html format.
# Copyright (C) 2000-2002  Stuart Ballard <sballard@netreach.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################

## GLOBAL VARIABLES ##

# Some global variables used for displaying stuff.
$japiover = "0.9.1";
$javatypes = {Z=>'boolean', B=>'byte', C=>'char', D=>'double', F=>'float',
                  I=>'int', J=>'long', S=>'short', V=>'void'};
@static = ('instance', 'static');

# Requirements
use IO::Handle;

my $verline = <>;
chomp $verline;
($filever, $orig, $new) = ($1, $2, $3)
    if $verline =~ /^%\%japio ([^ ]+) ([^ ]+) ([^ ]+)(?: .*)?$/;
unless (defined $filever) {
  print STDERR <<EOF;
This does not look like a japio file.
EOF
  exit 1;
}
if ($filever ne $japiover) {
  print STDERR <<EOF;
This japio file claims to be version $filever, but this version of japiotext
only supports version $japiover.
EOF
  exit 1;
}

print <<EOF;
<html>
  <head>
    <title>Results of comparison between $orig and $new</title>
    <link rel="stylesheet" type="text/css" href="japi.css">
  </head>
  <body>
    <h1>Results of comparison between $orig and $new</h1>
    <h2>Summary</h2>
    <p>Note that summary information is calculated prior to filtering the
       results (for duplicates, etc). It is possible to show a non-zero "bad" or
       "missing" score without any actual errors being listed.</p>
    <table class="summary" border="0" cellspacing="0" cellpadding="3">
      <tr class="colhead">
        <td></td>
        <th class="good">Good</th>
        <th class="bad">Bad</th>
        <th class="missing">Missing</th>
        <th class="abs-add">Abs.Add</th>
      </th>
EOF

my $alt = 0;
while (<>) {
  chomp;
  if (/^rawsummary (.*)$/) {
    my @bits = split / /, $1;
    my ($extra, $total, $values, $etotal) = ({}, 0, {}, 0);
    my $pkg = shift @bits;
    foreach my $bit (@bits) {
      my ($plus, $key, $value) = ($1, $2, $3)
        if $bit =~ /^(\+?)([^:+]+):([0-9]+)$/;
      if ($plus) {
        $etotal += $value;
        $extra->{$key} = $value + 0;
      } else {
        $total += $value;
        $etotal += $value;
        $values->{$key} = $value + 0;
      }
    }
    my $pkgn = $pkg;
    if ($pkg eq "#") {
      print "\n";
      $pkgn = "Total";
    } elsif ($pkg =~ /^#(.)(.*)$/) {
      $pkgn = uc($1) . $2;
      $pkgn .= "e" if $pkgn =~ /[sx]$/;
      $pkgn .= "s";
    }
    my $pctclass = 0;
    $pctclass = int($values->{good} * 10 / $etotal) * 10 if $values->{good};
    $alt = 1 - $alt;
    print <<EOF;
      <tr class="alternating-0">
        <th class="good-${pctclass}pct">$pkgn:</th>
EOF
    foreach my $key ("good", "bad", "missing", "abs.add") {
      my $val = "";
      if ($values->{$key}) {
        $val .= (int($values->{$key} * 10000 / $total)/100) . "%";
      } elsif ($extra->{$key}) {
        $val .= (int($extra->{$key} * 10000 / $total)/100) . "%";
      }
      my $class = $key; $class =~ s/\./-/g;
      print <<EOF;
        <td class="$class">$val</td>
EOF
    }

    use integer;

    # Now we need to integerize the percentages so we can emit a table whose
    # width (minus the "extra" bit) adds up to exactly 100 pixels. We also want
    # to ensure that *anything* nonzero gets at least a pixel. See the file
    # design/percent-rounding.txt for a justification of this algorithm.

    # Start off assuming nothing's less than 1%, and iterate until we find
    # that we're right. m is the number of adjustable (<1%) items, and t is
    # the total of the non-adjustable items. Lastm keeps track of what we
    # thought m was last time round. We loop until we do an entire pass without
    # m ending up different from lastm. Lastm starts off as -1 just so that the
    # m == lastm test fails first time around.
    my $t = $total;
    my $m = 0;
    my $lastm = -1;
    my $adjustable = {};
    until ($m == $lastm) {
      $lastm = $m;

      # Loop over the items that haven't already been marked adjustable. For
      # each such item, determine whether it needs to be adjustable based on
      # the current values of m and t. If it does, mark it as adjustable and
      # update m and t accordingly.
      foreach my $item (keys %$values) {
        if (!$adjustable->{$item}) {
          if ($values->{$item} * (100-$m) < $t) {
            $t -= $values->{$item};
            $m++;
            $adjustable->{$item} = 1;
          }
        }
      }
    }

    # Having calculated the final values of m and t, and also knowing exactly
    # which items are adjustable, we can now calculate the adjusted totals.
    # Non-adjustable items are scaled up by a constant factor; adjustable
    # items are all set to exactly 1% of the scaled total.
    my $adjtotal = 100 * $t;
    my $adjvalue = {};
    foreach my $item (keys %$values) {
      if ($adjustable->{$item}) {
        $adjvalue->{$item} = $t;
      } else {
        $adjvalue->{$item} = $values->{$item} * (100-$m);
      }
    }
       
    # Calculate the percentage rounded *down* to the nearest integer, and also
    # calculate the magnitude of the difference between the integer percentage
    # and the actual percentage. This is still all done in integer math...
    # While we're at it, sum the percentages so we can see how close we got,
    # later.
    my $totalpct = 0;
    my $percent = {};
    my $diff = {};
    foreach my $item (keys %$values) {
      $percent->{$item} = ($adjvalue->{$item} * 100) / $adjtotal;
      $diff->{$item} = $adjvalue->{$item} * 100 - $percent->{$item} * $adjtotal;
      $totalpct += $percent->{$item};
    }

    # Find the items with the largest differences, and adjust them upwards,
    # until 100% is reached. No need to reset the difference since we're looping
    # through the items and will never repeat: it's easy to show that the upper
    # bound on the number of upwards adjustments needed is smaller than the
    # number of items.
    foreach my $item (sort { $diff->{$b} <=> $diff->{$a} } keys %$values) {
      last if ($totalpct >= 100);
      $percent->{$item}++;
      $totalpct++;
    }

    foreach my $item (keys %$extra) {
      $percent->{$item} = ($extra->{$item} * 1000 + 5) / ($total * 10);
      $percent->{$item} = 1 unless $percent->{$item};
      $totalpct += $percent->{$item};
    }

    print <<EOF;
        <td>
          <table width="$totalpct" cellpadding="0" cellspacing="0" class="bar">
            <tr>
EOF
    foreach my $item ("good", "bad", "missing", "abs.add") {
      if (exists $percent->{$item}) {
        my $pct = $percent->{$item};
        my $class = $item; $class =~ s/\./-/g;
        print <<EOF if $pct;
              <td width="$pct" class="$class-bar">
                <img src="1x1.gif" width="1" height="1">
              </td>
EOF
      }
    }
    print <<EOF;
            </tr>
          </table>
        </td>
      </tr>
EOF
  } elsif (/^error /) {
  } else {
    die "Line not understood in japio file:\n$_";
  }
}
print <<EOF;
    </table>
  </body>
</html>
EOF
exit 0;
# Function prototypes
sub scmp(&;&);
sub japicmp($$);
sub sig2type($);
sub readable_member($);
sub open_japi($);
sub read_japi_item($);
sub close_japi($);
sub output_error($$$$$$;$);
sub compare_japis($$);
sub compare_japi_item($$$$);
sub merge_results();
sub print_summary();


## MAIN LOOP ##

# Parse cmdline and give a usage message.
getopts("svq", \%opts);
my $sun_only = 1 if $opts{"s"};
my $svuid_errors = 1 if $opts{"v"};
my $dot = $opts{"q"} ? "" : ".";
my ($origfile, $newfile) = @ARGV;
if (!defined $newfile) {
  print "Usage: japicompat [-svq] <original api> <api to check>\n";
  exit 1;
}

# Read in the old and new APIs.
$orig = open_japi($origfile);
$new = open_japi($newfile);

# Loop through the two files and compare them.
compare_japis($orig, $new);

# Close out the files now we're done with them.
close_japi($orig);
close_japi($new);

# Merge the results into a single stream of errors, and print them to stdout.
merge_results();

# Print a summary of what was found.
print_summary();


## SUBROUTINES ##

# Function for doing complicated comparisons. Returns a value equivalent to
# that returned by cmp. Takes 2 arguments: a function which tests whether $_ is
# in the 'preferred' set and a function to fall back on if neither or both are
# in the preferred set. The fallback function is called using a and b, as usual,
# and defaults to {$a cmp $b}.
sub scmp(&;&) {
  my ($prf, $flbk) = (@_, sub {$a cmp $b});
  $_ = $a; my $aprf = &$prf();
  $_ = $b; my $bprf = &$prf();
  $aprf && !$bprf ? -1 :
  $bprf && !$aprf ? 1 :
  &$flbk();
}

# Compare two japi entries pseudo-alphabetically.
sub japicmp($$) {
  my ($ia, $ib) = @_;
  return -1 unless defined $ib;
  japitemcmp($ia->{item}, $ib->{item});
}

sub japitemcmp($$) {
  ($a, $b) = @_;
  scmp {/^java\.lang,Object!/} sub {scmp {/^java\.lang[\.,]/}};
}

# Convert a type signature as used in a japi file to a displayable type.
sub sig2type($) {
  my ($sig) = @_;
  return sig2type($1) . '[]' if $sig =~ /^\[(.*)$/;
  return $javatypes->{$sig} if $javatypes->{$sig};
  if ($sig =~ /^L(.*);$/) {
    $sig = $1; $sig =~ s-/-.-g;
  }
  $sig;
}

# Convert all the type signatures in a method name...
sub readable_member($) {
  my ($member) = @_;
  if ($member =~ /^(.*)\((.*)\)$/) {
    my ($name, $params) = ($1, $2);
    my @params = split /,/, $2;
    $params = join(',', map {sig2type($_)} @params);
    $member = "$name($params)";
  } elsif ($member =~ /^#(.*)$/) {
    $member = $1;
  }
  $member;
}

sub open_japi($) {
  my ($filename) = @_;
  my $japi;
  $japi->{name} = $filename;
  my $fh;
  if ($filename =~ /\.gz$/) {
    $fh = new IO::Pipe()->reader("gzip", "-dc", $filename);
    die "Could not pipe from gzip: $!" unless $fh;
  } else {
    $fh = new IO::File("<$filename");
    die "Could not open $filename: $!" unless $fh;
  }
  print STDERR "Loading $filename" if $dot;
  my $japiline = $fh->getline;
  chomp $japiline;
  die <<EOF unless $japiline =~ /^%\%japi ([^ ]*)(?: .*)?$/;

This looks like an old-style japi file. The format was changed since version
0.7 to save disk space and avoid a theoretically possible ambiguity. Most
new japis are approx. 30% smaller than the coresponding old-style ones. It was
changed again since version 0.8 to allow japicompat to use smarter algorithms.
You can use japifix to convert to the new format.
EOF
  my $filever = $1;
  die <<EOF if $filever lt $japiver;

This japi file claims to be version $filever, but this version of japicompat
only understands version $japiver. You can use japifix to upgrade old japi
files to version $japiver.
EOF
  die <<EOF if $filever gt $japiver;

This japi file claims to be version $filever, but this version of japicompat
only understands version $japiver. Either the japi file is incorrect or you need
a new version of japicompat.
EOF
  print STDERR ".\n" if $dot;
  $japi->{fh} = $fh;
  return $japi;
}

sub read_japi_item($) {
  my ($japi) = @_;
  my $fh = $japi->{fh};
  my $line = $fh->getline;
  return undef unless $line;
  chomp $line;
  
  # Parse and interpret the entry.
  my ($item, $flags, $type) = split / /, $line, 3;

  # Ensure that this item is correctly ordered.
  die "\nIncorrect ordering of $japi->{name}:\n$japi->{last_item} >=\n$item"
    if defined($japi->{last_item}) &&
       japitemcmp($japi->{last_item}, $item) >= 0;
  $japi->{last_item} = $item;

  my ($fqcn, $member) = split /!/, $item, 2;
  my ($pkg, $class) = split /,/, $fqcn, 2;
  my $isa;
  if ($member eq "") {
    $isa = $type =~ /^class/ ? "class" : "interface";
  } elsif ($member =~ /^\(.*\)$/) {
    $isa = "constructor";
  } elsif ($member =~ /\(.*\)$/) {
    $isa = "method";
  } elsif ($member =~ /^#(.*)$/) {
    $isa = "field";
    $member = $1;
  } else {
    die <<EOF;

Could not interpret item in japi file:
$line
Either this japi file is corrupt or you have uncovered a bug in japicompat.
Please email this error message in full to sballard\@netreach.net.
EOF
  }

  # Store information about the entry in $japi->{$pkg}->{$class}->{$member}.
  my $mitem = {};
  $mitem->{item} = $item;
  $mitem->{isa} = $isa;
  $mitem->{class} = $class;
  $mitem->{package} = $pkg;
  $mitem->{member} = $member;
  $mitem->{rmember} = readable_member($member);
  my ($public, $abstract, $static, $final) = split //, $flags;
  $mitem->{public} = ($public eq 'P' || 0);
  $mitem->{abstract} = ($abstract eq 'a' || 0);
  $mitem->{static} = ($static eq 's' || 0);
  $mitem->{final} = ($final eq 'f' || 0);

  # Classes and interfaces have superclasses and implemented interfaces tacked
  # on to the "type" field. We store this information in the $japi hash also.
  if ($member eq "") {

    # Get the interfaces data, which is separated by '*'s from the classname.
    my @ifaces = split(/\*/, $type);
    $type = shift @ifaces;
    $mitem->{ifaces} = {};
    foreach my $iface (@ifaces) {
      $mitem->{ifaces}->{$iface} = 1;
    }

    # Get the class's superclasses, which are separated by ':'s.
    my @supers = split(/:/, $type);
    $type = shift @supers;
    my $ct = 0;
    $mitem->{supers} = [];
    foreach my $super (@supers) {
      $mitem->{superset}->{$super} = 1;
      $mitem->{supers}->[$ct++] = $super;
    }

    my $svuid;
    ($type, $svuid) = split(/#/, $type, 2);
    $mitem->{svuid} = $svuid if defined $svuid;

  # Methods and constructors have exceptions that can be thrown separated by
  # '*'s from the typename. These also need to get stored in the hash.
  } elsif ($member =~ /\(.*\)$/) {
    my @excps = split(/\*/, $type);
    $type = shift @excps;
    foreach my $excp (@excps) {
      $mitem->{excps}->{$excp} = 1;
    }
  # Fields can have their value separated by a : from the typename, if they
  # are constant.
  } else {
    my $val;
    ($type, $val) = split(/:/, $type, 2);
    $mitem->{constant} = $val if defined $val;
  }

  # Store what's left of the type after parsing off all of those parts.
  $mitem->{type} = $type;

  return $mitem;
}

sub close_japi($) {
  my ($japi) = @_;
  my $fh = $japi->{fh};
  close $fh;
}

sub inc($$$$;$) {
  my ($c, $pkg, $isa, $etype, $count) = (@_, 1);
  $c->{"$pkg/$etype"} += $count;
  $c->{"#$isa/$etype"} += $count;
  $c->{"/$etype"} += $count;
}

sub output_error($$$$$$;$) {
  my ($oitem, $nitem, $oclitem, $c, $etype, $error, $count) = (@_, 1);
  my ($supct, $sups);
  if ($oitem->{isa} eq "package") {
    $supct = 0;
    $sups = "";
  } else {
    $supct = scalar @{$oclitem->{supers}} + keys %{$oclitem->{ifaces}};
    $supct++ unless $supct;
    $sups = join ";", @{$oclitem->{supers}}, keys %{$oclitem->{ifaces}};
  }
  unless ($ofhs[$supct]) {
    $ofhs[$supct] = new_tmpfile IO::File();
  }
  print {$ofhs[$supct]} "$sups $etype $oitem->{isa} $oitem->{item} $error\n";
  inc($c, $oitem->{package}, $oitem->{isa}, $etype, $count)
    unless $errhere;
  $errhere = 1;
}

sub pct($$$$) {
  my ($c, $pkg, $etype, $str) = @_;
  my $ct = $c->{"$pkg/$etype"};
  return $str unless $ct;
  my $tot = $c->{"$pkg/total"};
  $str .= ", " if $str;
  return $str . ((int (10000 * $ct / $tot)) / 100) . "% $etype";
}

sub short_summary($$) {
  my ($c, $pkg) = @_;
  my $pkgn = $pkg || "Total";
  if ($pkg =~ /^#(.)(.*)$/) {
    $pkgn = uc($1) . $2;
    $pkgn .= "e" if $pkgn =~ /[sx]$/;
    $pkgn .= "s";
  }
  my $summ = pct($c, $pkg, "good", "");
  $summ = pct($c, $pkg, "bad", $summ);
  $summ = pct($c, $pkg, "missing", $summ);
  $summ = pct($c, $pkg, "abs.add.", $summ);
  print "$pkgn: $summ\n";
  print "\n" unless $pkg;
  print STDERR "\r$pkgn: $summ\n" if $dot;
}

# Loop through all the packages in the original API and process them.
sub compare_japis($$) {
  my ($orig, $new) = @_;

  my $pkg = "";
  my $class = "";
  my $c = {}; # counts
  my $oitem = read_japi_item($orig);
  my $nitem = read_japi_item($new);
  my ($oclitem, $nclitem);
  print STDERR "Comparing...\n" if $dot;
  while (defined $oitem) {
    inc($c, $oitem->{package}, $oitem->{isa}, "total");
    my $isnewpkg = ($pkg ne $oitem->{package});
    my $isnewclass = $isnewpkg || ($class ne $oitem->{class});
    my $cmp;
    my $first = 1;
    while (($cmp = japicmp($oitem, $nitem)) > 0) {
      $errhere = 0;

      # Keep an eye out for members that are abstract that are also not in
      # the original. This check is not in the JLS, so only do it if sun_only
      # is false.
      if (!$sun_only && !$first && $nitem->{abstract} &&
          $nitem->{package} eq $pkg && $nitem->{class} eq $class) {
        output_error($nitem, $nitem, $oclitem, $c, "abs.add.",
                     "- abstract method added to $nclitem->{isa}");
      }
      $first = 0;
      $nitem = read_japi_item($new);
    }
    if ($isnewpkg) {
      short_summary($c, $pkg) if $pkg;
      print STDERR $oitem->{package} if $dot;
    }
    print STDERR $dot if $isnewclass;
    $pkg = $oitem->{package};
    $class = $oitem->{class};
    $oclitem = $oitem if $isnewclass;
    $errhere = 0;
    if ($cmp) {
      my $ecount = 1;
      my $eitem = {%$oitem};
      if ($isnewpkg && (!defined($nitem) ||
                        $nitem->{package} ne $oitem->{package})) {
        $eitem->{isa} = "package";
        $eitem->{class} = "";
        $eitem->{item} = "$pkg,!";
        while (defined $oitem && $oitem->{package} eq $pkg) {
          $oitem = read_japi_item($orig);
          if (defined $oitem && $oitem->{package} eq $pkg) {
            inc($c, $pkg, $oitem->{isa}, "total");
            $ecount++;
          }
        }
      } elsif ($isnewclass) {
        while (defined $oitem && $oitem->{package} eq $pkg &&
               $oitem->{class} eq $class) {
          $oitem = read_japi_item($orig);
          if (defined $oitem && $oitem->{package} eq $pkg &&
              $oitem->{class} eq $class) {
            inc($c, $pkg, $oitem->{isa}, "total");
            $ecount++;
          }
        }
      } else {
        $oitem = read_japi_item($orig);
      }
      output_error($eitem, undef, $oclitem, $c, "missing",
                   "present in $origfile but missing in $newfile", $ecount);
    } else {
      $nclitem = $nitem if $isnewclass;
      inc($c, $pkg, $oitem->{isa}, "good")
        unless compare_japi_item($oitem, $nitem, $oclitem, $c);
      $oitem = read_japi_item($orig);
    }
  }

  # New abstract members in a class might show up even at the end of the file,
  # after the last item in orig.
  my $first = 1;
  while (!$sun_only && defined $nitem &&
         $nitem->{package} eq $pkg && $nitem->{class} eq $class) {
    $errhere = 0;

    # Keep an eye out for members that are abstract that are also not in
    # the original. This check is not in the JLS, so only do it if sun_only
    # is false.
    if (!$first && $nitem->{abstract}) {
      output_error($nitem, $nitem, $oclitem, $c, "abs.add.",
                   "- abstract method added to $nclitem->{isa}");
    }
    $first = 0;
    $nitem = read_japi_item($new);
  }
  short_summary($c, $pkg) if $pkg;
  short_summary($c, "");
}

sub compare_japi_item($$$$) {
  my ($oitem, $nitem, $oclitem, $c) = @_;

  my $isa = $oitem->{isa};
  my $member = $oitem->{member};

  # Check that access to the item hasn't been reduced.
  if ($oitem->{public} && !$nitem->{public}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "is public in $origfile but protected in $newfile");
  }

  # Check that the item hasn't changed from concrete to abstract.
  if (!$oitem->{abstract} && $nitem->{abstract}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "is concrete in $origfile but abstract in $newfile");
  }

  # Check that the staticness of the item hasn't changed
  if ($oitem->{static} != $nitem->{static}) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "is $static[$oitem->{static}] in $origfile but $static[$nitem->{static}] in $newfile");
  }

  # Check that the item hasn't gone from nonfinal to final, except
  # for static methods.
  if (!$oitem->{final} && $nitem->{final} &&
      ($oitem->{isa} ne "method" || !$oitem->{static})) {
    output_error($oitem, $nitem, $oclitem, $c, "bad",
                 "is nonfinal in $origfile but final in $newfile");
  }

  # For classes and interfaces, check that nothing has been removed from
  # the set of super-interfaces or superclasses.
  if ($member eq "") {
    foreach my $iface (keys %{$oitem->{ifaces}}) {
      unless ($nitem->{ifaces}->{$iface}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "implements $iface in $origfile but not in $newfile");
      }
    }
    my $super = $oitem->{supers}->[0];
    if (defined $super and !$nitem->{superset}->{$super}) {
      output_error($oitem, $nitem, $oclitem, $c, "bad",
                   "'s superclass $super in $origfile is not its superclass in $newfile");
    }

    # Also check the SerialVersionUID if that is turned on.
    if ($svuid_errors && defined $oitem->{svuid}) {
      if (!defined $nitem->{svuid}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "has SerialVersionUID $oitem->{svuid} in $origfile but no SVUID in $newfile");
      } elsif ($nitem->{svuid} ne $oitem->{svuid}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "has SerialVersionUID $oitem->{svuid} in $origfile but $nitem->{svuid} in $newfile");
      }
    }

  # For methods and constructors, check that the set of thrown exceptions
  # is the same. The JLS does not specify this so only do it if not
  # sun_only.
  } elsif ($member =~ /\(.*\)/ && !$sun_only) {
    foreach my $excp (keys %{$oitem->{excps}}) {
      unless ($nitem->{excps}->{$excp}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "throws $excp in $origfile but not in $newfile");
      }
    }
    foreach my $excp (keys %{$nitem->{excps}}) {
      unless ($oitem->{excps}->{$excp}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "throws $excp in $newfile but not in $origfile");
      }
    }

  # For fields, check the constant value if there is one.
  } else {
    if (defined $oitem->{constant}) {
      if (!defined $nitem->{constant}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "is constant [$oitem->{constant}] in $origfile but nonconstant in $newfile");
      } elsif ($nitem->{constant} ne $oitem->{constant}) {
        output_error($oitem, $nitem, $oclitem, $c, "bad",
                     "is constant [$oitem->{constant}] in $origfile but [$nitem->{constant}] in $newfile");
      }
    }
  }

  # Check that the item's type has remained the same.
  if ($oitem->{type} ne $nitem->{type}) {
    unless ($oitem->{isa} eq "field" && $oitem->{type} !~ /:/ &&
            $nitem->{type} =~ /^\Q$oitem->{type}\E:/) {
      output_error($oitem, $nitem, $oclitem, $c, "bad",
                   "'s type in $origfile [@{[sig2type($oitem->{type})]}] does not match $newfile [@{[sig2type($nitem->{type})]}]");
      # Do I win the award for "most consecutive close brackets"?
    }
  }
  return $errhere;
}

sub merge_results() {
  my $errs = {};
  $sc = {};
  print STDERR "Merging results / eliminating dups...\n" if $dot;
  foreach my $fh (@ofhs) {
    if ($fh) {
      $fh->seek(0, 0);
      while (<$fh>) {
        chomp;
        my ($sups, $etype, $isa, $item, $rest) = split(/ /, $_, 5);
        my ($class, $member) = split(/!/, $item, 2);
        my @sups = split(/;/, $sups);
        my $insup = 0;

        # Determine whether the same error appears in any superclass, and if so
        # do not report this error. That doesn't apply, though, to missing
        # classes, which should be reported regardless of whether their
        # superclass is missing too. It also doesn't apply to errors in
        # constructors, since they aren't inherited.
        unless ((($isa eq 'class' || $isa eq 'interface') &&
                 $etype eq 'missing') ||
                $isa eq 'constructor') {
          foreach my $sup (@sups) {
            $insup = 1 if $errs->{"$sup\!$member $rest"};
          }
        }
        unless ($insup) {
          my ($pkg, $cls) = split(/,/, $class, 2);
          $class = "$pkg.$cls";
          $errs->{"$class\!$member $rest"} = 1;
          print "$isa $class.".readable_member($member)." $rest\n";
          $totalerrors++;
          inc($sc, $pkg, $isa, $etype);
        }
      }
      $fh->close();
      undef $fh;
    }
  }
  print STDERR "Done.\n" if $dot;
}

sub ct($$$$) {
  my ($c, $pkg, $etype, $str) = @_;
  my $ct = $c->{"$pkg/$etype"};
  return $str unless $ct;
  $str .= ", " if $str;
  return "$str$ct $etype";
}

sub count_summary($$) {
  my ($c, $pkg) = @_;
  my $pkgn = $pkg || "Total";
  if ($pkg =~ /^#(.)(.*)$/) {
    $pkgn = uc($1) . $2;
    $pkgn .= "e" if $pkgn =~ /[sx]$/;
    $pkgn .= "s";
  }
  my $summ = ct($c, $pkg, "good", "");
  $summ = ct($c, $pkg, "bad", $summ);
  $summ = ct($c, $pkg, "missing", $summ);
  $summ = ct($c, $pkg, "abs.add.", $summ);
  $summ = "All good" unless $summ;
  print "$pkgn: $summ\n";
  print STDERR "\r$pkgn: $summ \n" if $dot;
}
# Print summary information.
sub print_summary() {
  print "\n";
  print STDERR "\n" if $dot;
  count_summary($sc, "#package");
  count_summary($sc, "#class");
  count_summary($sc, "#interface");
  count_summary($sc, "#field");
  count_summary($sc, "#constructor");
  count_summary($sc, "#method");
  print "$totalerrors unique errors found.\n";
  print STDERR "$totalerrors unique errors found.\n" if $dot;
}
