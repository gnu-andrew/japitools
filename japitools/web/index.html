<html><head><title>japitools: Java API compatibility testing</title></head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#8800ff">
<h1>japitools: Java API compatibility testing tools</h1>
<p>japitools consists of two simple tools designed to test for compatibility
between Java APIs. They were originally designed for testing free
implementations of Java itself for compatibility with Sun's JDK, but they can
also be used for testing backward compatibility between versions of any API.</p>
<p>The tools are <a href="#japize">japize</a>
and <a href="#japicompat">japicompat</a>. Japize is a java program which
uses the jode.bytecode library to emit a listing of an API in a machine-readable
format. Japicompat then takes two such listings and compares them for binary
compatibility, as defined by Sun in the
<a href="http://java.sun.com/docs/books/jls/html/13.doc.html">Java Language Specification</a>
(and as amended
<a href="http://java.sun.com/docs/books/jls/clarify.html">here</a>).</p>
<h3>News</h3>
<ul>
  <li>10 September 2002: Released japitools-0.8.5. This fixes numerous problems
      in the files produced by japize, bringing it finally back to parity with
      release 0.8 or so. Japicompat will now abort on mis-ordered files, so that
      errors like this will be caught quicker next time. Japi2new got a facelift
      and is now called japifix. Much more testing, leading me to conclude that
      japicompat is now <em>more</em> trustworthy than japicompat-old.</li>
  <li>31 July 2002: Released a brown-paper-bag japitools-0.8.4 with a fix for
      a hang-at-end-of-file bug that showed up whenever the 'orig' file contains
      packages or classes at the end of the file that aren't in the 'new' file.
      Oooops!</li>
  <li>31 July 2002: Released japitools-0.8.3 with a rewritten japicompat that
      uses a much faster and more scalable algorithm. Of course, being a total
      rewrite, there's a risk of regressions, so the old japicompat is still
      available as japicompat-old (and, in fact, includes a fix or two over the
      0.8.2 version). The other casualty of the rewrite is that although some
      summary information is better, some is also worse. I hope to resurrect the
      bits of what was lost that make sense. Also updated the docs below so that
      they match the state of reality since 0.8.1.</li>
  <li>9 July 2002: Released japitools-0.8.2 with a fix for a NullPointer.
      There's more work in progress on my laptop that isn't included in this
      release because it's not ready yet, but hopefully soon there'll be a first
      pass at the optimized algorithm for japicompat.</li>
  <li>28 June 2002: Released japitools-0.8.1. Noted that this obsoletes some
      of the documentation on the website. Removed a bunch of old results
      files that aren't correct any more. The docs will have to be updated
      later - no time now.</li>
  <li>19 March 2002: Updated the website so that the documentation matches the
      actual current code. Since it's been almost 2 years since I wrote this,
      I can't be 100% sure that this documentation is all correct, but it's
      certainly better than it was before!</li>
  <li>28 June 2000: Finally bundled japitools up into a jarball which I'm
      calling version 0.8 (which is a good indicator of how close to "complete"
      I feel it is). It now requires the jode.bytecode package if you want to
      get good results, although you can still use the old buggy reflection
      version. See below for details.</li>
  <li>18 June 2000: At the suggestion of Edouard G. Parmelan, added support
      for checking SerialVersionUIDs. Since this will generally produce lots
      of errors and make it harder to identify more important API compatibility
      errors, it needs to be explicitly turned on in japicompat by passing the
      -v flag.</li>
  <li>16 June 2000: Godmar fixed the remaining Kaffe bug, so I've removed the
      hackaround. I still need to leave part of it in due to a subtlety in the
      way superinterfaces are defined by the JLS. japicompat now removes
      duplicates, cutting the number of Kaffe errors to 142, and checks
      everything in the JLS plus my four additions. Reflection is incapable of
      telling me if a field is a primitive constant, buggrit, so I have to
      move to using something like gnu.bytecode.</li>
  <li>15 June 2000: Japize is now, finally, well commented. Godmar Back kindly
      fixed one of the Kaffe bugs which will mean that some hackarounds can be
      removed Real Soon (once another related bug gets fixed). I've been hacking
      japicompat to allow duplicates to be removed; you can find the code
      <a href="japicompat2.pl">here</a>. It doesn't actually <b>do</b> the
      removal yet, but the architecture is in. This will replace japicompat once
      I'm convinced it's as robust; early signs look good. It's also commented!
      Certify me on <a href="http://www.advogato.org/person/sab39">Advogato</a>
      - or don't, but it really is me! I need to figure how I'm going to version
      japitools - right now, all the links here are to my working copies...</li>
</ul>

<h3>Installation</h3>
<p>You can download <a href="japitools-0.8.5.tar.gz">japitools-0.8.5.tar.gz</a>
here. This tarball contains japitools.jar which should be placed in your
CLASSPATH, and a bin/ directory containing all the tools for working with japi
files. It also contains sources for everything in case you want to do
development.  You will need Jode 1.1.1, available
from <a href="http://jode.sourceforge.net/">here</a>
(<a href="jode-1.1.1.jar">local mirror of jode jarball</a>).
<p>The tools in the bin directory assume that perl is /usr/bin/perl.</p>

<h3>Usage</h3>
<p>Using japitools is a two-step process:</p>
<ul><li>Use japize to generate a .japi file for each of the versions you want
to compare.</li>
<li>Use japicompat to compare one for backwards compatibility with the
other</li></ul>
<h4><a name="japize">japize</a></h4>
<p>The general usage of japize is as follows:</p>
<pre>$ japize zip|unzip [as &lt;name&gt;] apis &lt;zipfile&gt; | &lt;dir&gt; ... +|-&lt;pkgpath&gt; ...</pre>
<p>At least one +&lt;pkgpath&gt; is required. The word "reflect" can appear
before "apis", but this is unreliable and deprecated. &lt;name&gt; will have
".japi" and/or ".gz" appended as appropriate.</p>
<p>The word "apis" can be replaced by "explicitly", "byname", "packages" or
"classes". These options indicate whether something of the form "a.b.C" should
be treated as a class or a package. You may specify this unambiguously by using
one of the forms "a.b.cpackage," or "a.b,CClass".</p>
<p>That's the one-paragraph overview, pretty much equivalent to what you get if
you type "japize" with no arguments. In detail, the options available are as
follows:</p>
<h4>zip|unzip</h4>
<p>Specifying the "zip" option indicates that japize should gzip its output.
Specifying "unzip" indicates that it shouldn't. Zipping the output is highly
recommended since it saves huge amounts of space (japi files are
large but extremely compressable because they contain large numbers of duplicate
strings. Factor-of-ten compression seems to be typical). The only situations
where you might not want to use gzip compression are when memory and CPU usage
are extremely tight (zipping and unzipping both require more memory the larger
the file gets, and require more CPU usage - on todays computers this is rarely
an issue, though) or if your JVM does not implement GZIPOutputStream correctly
(in which case you might still want to gzip the resulting file manually).</p>
<p>In previous releases "zip" was an option and "unzip" was not available as
an option, because it was the implicit default. Since zipping is the recommended
mode of operation, "zip" will become the implicit default in future versions.
Japitools 0.8.5 requires an explicit selection of this option to avoid surprises
caused by silently changing the default. Japitools 0.9 will accept "zip" as a
no-op; future versions will refuse it entirely.</p>
<h4>as &lt;name&gt;</h4>
<p>Specifying this option tells japize to write its output to a file with the
specified name. If this option is omitted, japize will write to standard output.
When writing to a file, japize insists on writing to a filename ending in .japi
for uncompressed files, or .japi.gz for compressed files. If the filename you
specify doesn't have the right extension, japize will add parts to it to ensure
that it does.</p>
<h4>reflect</h4>
<p>This option is unreliable in several common scenarios, and therefore
considered deprecated. It tells japize to use reflection to look up API
information, instead of using Jode to parse the class files. Reflection does
not provide access to information about whether a static final field is constant
or not, and also uses far more memory. I have a hard time imagining any
legitimate use for this option.</p>
<p>As if that weren't enough reason for you to steer clear, bear in mind too
that when invoked in this way, japize cannot load classes from the zipfiles
or directories that you specify. Instead it will scan the paths you give it for
class <b>names</b>, but use a regular Class.forName() call to actually look at
the class contents. This means that to get API information for a given Java
implementation with this option, you must use that JVM to run japize. The japize
executable uses whatever is "java" in your system path.</p>
<h4>apis | explicitly | byname | packages | classes</h4>
<p>This option has a dual role: it indicates the boundary between japize options
(zip, as, reflect) and other arguments (files and packages), but also tells
japize how to deal with ambiguously specified arguments. See
"+|-&lt;pkgpath&gt;" below for details on the behavior of each option. If you
are unsure which to specify, "apis" is a safe choice.</p>
<h4>&lt;zipfile&gt; | &lt;dir&gt;</h4>
<p>Any arguments after "apis" that do not start with "+" or "-" are taken to be
zipfiles or directories. These should be specified exactly as you would put
them in your CLASSPATH (except separated by spaces rather than colons). Anything
that's a file will be assumed to be a zip (or jar) file, so you can't specify
a .class file directly - if you need to do that you should specify the folder
containing it and then name the class for processing.</p>
<h4>+|-&lt;pkgpath&gt;</h4>
<p>To specify which classes are included, use +pkgpath to add pkgpaths to be
scanned and -pkgpath to exclude sub-pkgpaths of these. You MUST specify at least
one +pkgpath option to specify which pkgpath to include, otherwise Japize could
happily scan through all the zipfiles and directories but not actually process
any of the classes. Since that would be a useless thing to do, japize gives an
error instead.</p>
<p>A "pkgpath" refers to either a package (which includes, by implication, all
sub-packages of it) or a single class. A pkgpath for a package looks like
"com.foo.pkg.sub," and a pkgpath for a class looks like "com.foo.pkg,Cls". The
existence and placement of the comma indicates unambiguously which type of path
is intended.</p>
<p>Most of the time, though, it's a pain to have to put in commas in names that
are familiar with dots instead, and get the comma placement exactly right. For
this reason, japize accepts pkgpaths containing only dots, and lets you tell it
what to make of those names. The interpretation of "a.b.c" as a pkgpath depends
on whether you specified apis, explicitly, byname, packages, or classes.</p>
<dl>
  <dt>apis</dt>
  <dd>a.b.c is tried both as a package <i>and</i> a class. This will always do
      what you want (which is why apis is described as the safe default) but at
      the expense of possibly doing extra unnecessary processing trying to find
      the wrong thing.</dd>
  <dt>explicitly</dt>
  <dd>pkgpaths of the form a.b.c are illegal - you must use the explicit
      form.</dd>
  <dt>byname</dt>
  <dd>a.b.c will be processed as a package if "c" starts with a lowercase
      letter, or as a class if it starts with an uppercase one. This usually
      does what you want but fails on things like org.omg.CORBA.
  <dt>packages</dt>
  <dd>a.b.c will be processed as a package. If processing for a class is needed,
      it must be specified explicitly.</dd>
  <dt>classes</dt>
  <dd>a.b.c will be processed as a class. If processing for a package is needed,
      it must be specified explicitly.</dd>
</dl>
<h4>Example</h4>
<p>As an example, Sun's
JDK 1.1 includes classes in java.awt.peer and in java.text.resources that are
not part of the public API, even though they are public classes; however, every
other class in the java.* package hierarchy is part of the public API. The
syntax to construct a useful jdk11.japi.gz would therefore be:</p>
<pre>$ japize zip as jdk11 apis classes.zip +java -java.awt.peer -java.text.resources</pre>
<p>Note that since all pkgpath arguments here are packages, you could save a
small amount of processing by doing this instead:</p>
<pre>$ japize zip as jdk11 packages classes.zip +java -java.awt.peer -java.text.resources</pre>
<p>or even this:</p>
<pre>$ japize zip as jdk11 explicitly classes.zip +java, -java.awt.peer, -java.text.resources,</pre>
<p>Another example, this time doing the same thing for kaffe:</p>
<pre>$ japize zip as kaffe packages $KAFFEHOME/share/kaffe/Klasses.jar $KAFFEHOME/share/kaffe/rmi.jar +java -java.awt.peer -java.text.resources</pre>
<h4><a name="japicompat">japicompat</a></h4>
<p>Next, you can perform the test for compatibility between these two files:
<pre>
$ japicompat jdk11.japi.gz kaffe.japi.gz
</pre>
<p>Either compressed (.japi.gz) or uncompressed (.japi) files can be passed to
japicompat: The file extension is used to determine whether or not to pipe input
through gzip or not. japicompat reports its progress to standard error and
the specific errors to standard output, so you can redirect standard output
to watch the progress without getting spammed by verbose error messages.
However, the output should happen in a sensible order even if this is not
done. Future versions of japicompat will support more flexible output,
including HTML.</p>
<p>By default, japicompat tests for binary compatibility as defined by the JLS,
plus a couple of additions (see below for details). You can turn off these
additions by passing the -s flag to japicompat, for example:</p>
<pre>
$ japicompat -s jdk11.japi.gz kaffe.japi.gz
</pre>
<p>The s stands for "sun", "standard", "specification", or if you like more
colorful language, "single-buttocked" (one buttock=half an...)</p>
<p>japicompat can also check that Serializable classes have the same
SerialVersionUID number from one release to the next. Because in most cases
this is likely to produce lots of errors, it needs to be explicitly turned on
by passing the -v flag to japicompat, for example:</p>
<pre>
$ japicompat -v jdk11.japi.gz kaffe.japi.gz
</pre>
<p>The v stands for serial "version" or "verbose".</p>
<h3>What exactly does japicompat test?</h3>
<p>As mentioned above, japicompat tests for binary compatibility as defined
by Sun in the JLS. A full summary of what does and does not break binary
compatibility according to Sun is <a href="jcompat.txt">here</a>.</p>
<p>However, japicompat also performs some checks that are not specified by the
JLS, for the simple reason that I believe the JLS is wrong to omit them. You can
omit these four extra checks by passing the "-s" flag to japicompat, although
I'm not sure why you would want to...</p>
<p>The specific checks that I believe the JLS should include are:</p>
<ul>
<li><i>Adding an exception to the throws clause of a method or constructor
    violates binary compatibility</i>, because a class calling that method may
    not catch or specify the newly thrown exception. The JLS claims that the
    VM does not perform any checks on thrown exceptions; I hope this has
    changed because it makes it trivially easy to write a method that throws
    any exception you like without specifying it.</li>
<li><i>Removing an exception from the throws clause of a method or constructor
    violates binary compatibility</i>, because a subclass may be overriding
    the method and throwing the exception. This only applies to non-final
    methods, but it is worth enforcing this rule for all methods and
    constructors because otherwise it is possible to break source code
    compatibility by rendering code in a catch block unreachable.</li>
<li><i>Adding a method to an interface violates binary compatibility</i>,
    because a class that implemented the original version of the interface
    may not implement the newly added method.</li>
<li><i>Adding an abstract method to an abstract class violates binary
    compatibility</i>, because a concrete class derived from the original
    version may not provide a concrete implementation of the new method.
</ul>

<p>japicompat specifically tests that the second argument is
backwardly-compatible with the first. Therefore, a perfect implementation of
JDK 1.1 would produce no errors regardless of the order of the arguments, but a
perfect implementation of JDK1.1 plus *parts* of JDK1.2 should be tested as
follows:</p>
<pre>$ japicompat jdk11.japi.gz kaffe.japi.gz
$ japicompat kaffe.japi.gz jdk12.japi.gz</pre>
<p>It is probably impossible to make an implementation that passes both these
tests, since Sun's own JDK1.2 produces numerous errors when tested against
JDK1.1.</p>

<h3>License</h3>
<p>These programs are made available under the
<a href="http://www.gnu.org/copyleft/gpl.html"</a>GNU General Public License</a>,
version 2 or later.</p>

<h3>To do</h3>
<p>Here is an incomplete list of what still needs to be done:</p>
<ul>
<li>Figure out a way to ignore errors that are present in Sun's implementation
    too - that is, if <tt>japicompat.pl jdk11.japi.gz jdk12.japi.gz</tt>
    produces a given error, then ignore it when running <tt>japicompat.pl
    jdk11.japi.gz kaffe.japi.gz</tt>.
<li>Construct jdk10.japi.gz, jdk11.japi.gz, jdk12.japi.gz and jdk13.japi.gz
    using the latest japize, and publish a tarball of them.</li>
<li>Set up a nightly checkout of Kaffe, Classpath and libgcj, if possible, and
    run automated japicompat tests against all the jdk versions.</li>
<li>Fix any bugs that anyone finds...</li>
<li>Handle APIs containing international characters in class/member names, and
    also international characters in final constant Strings.</li>
<li>Make a "1.0" release.</li>
<li>Write a japi2java tool, just because I can...</li>
</ul>
<p>Another to-do list with most of these same todos broken down by hypothetical
future release number can be found in the jarball in design/TODO.</p>
</body></html>

